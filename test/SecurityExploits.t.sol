// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../contracts/ILRM.sol";
import "../contracts/Treasury.sol";
import "../contracts/DIDRegistry.sol";
import "../contracts/L3Bridge.sol";
import "../contracts/L3StateVerifier.sol";
import "../contracts/L3DisputeBatcher.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title SecurityExploits
 * @notice Comprehensive security and exploit test suite for NatLangChain ILRM Protocol
 * @dev Tests for reentrancy, access control, economic exploits, front-running, DoS, and more
 */

// ============ Mock Contracts ============

contract MockToken is ERC20 {
    constructor() ERC20("StakeToken", "STK") {
        _mint(msg.sender, 100_000_000 ether);
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract MockAssetRegistry is IAssetRegistry {
    mapping(uint256 => bool) public frozen;
    mapping(uint256 => bytes32) public appliedFallback;

    function freezeAssets(uint256 disputeId, address) external override {
        frozen[disputeId] = true;
    }

    function unfreezeAssets(uint256 disputeId, bytes calldata) external override {
        frozen[disputeId] = false;
    }

    function applyFallbackLicense(uint256 disputeId, bytes32 termsHash) external override {
        appliedFallback[disputeId] = termsHash;
    }
}

contract MockOracle is IOracle {
    function verifySignature(uint256, bytes32, bytes calldata) external pure override returns (bool) {
        return true;
    }
}

// ============ Attack Contracts ============

/**
 * @notice Reentrancy attacker for Treasury ETH withdrawal
 */
contract TreasuryReentrancyAttacker {
    NatLangChainTreasury public treasury;
    uint256 public attackCount;
    uint256 public maxAttacks;

    constructor(address _treasury) {
        treasury = NatLangChainTreasury(payable(_treasury));
        maxAttacks = 3;
    }

    function attack() external {
        // This would exploit if emergencyWithdrawETH had no checks
        // Currently owner-only, so this tests the modifier works
    }

    receive() external payable {
        if (attackCount < maxAttacks) {
            attackCount++;
            // Attempt reentrant call - would fail if protected
            // treasury.emergencyWithdrawETH(address(this), 1 ether);
        }
    }
}

/**
 * @notice MEV front-runner for fraud proofs
 */
contract FraudProofFrontrunner {
    L3Bridge public bridge;

    constructor(address _bridge) {
        bridge = L3Bridge(payable(_bridge));
    }

    function frontrunFraudProof(IL3Bridge.FraudProof calldata proof) external payable {
        bridge.submitFraudProof{value: msg.value}(proof);
    }

    receive() external payable {}
}

/**
 * @notice DoS attacker for batch operations
 */
contract BatchGriefingAttacker {
    L3DisputeBatcher public batcher;

    constructor(address _batcher) {
        batcher = L3DisputeBatcher(_batcher);
    }

    function fillBatchWithSpam() external {
        // Fill batch with spam disputes to DoS legitimate users
        for (uint256 i = 0; i < 50; i++) {
            IL3Bridge.DisputeInitiationMessage memory msg_ = IL3Bridge.DisputeInitiationMessage({
                l2DisputeId: 999000 + i,
                initiator: address(this),
                counterparty: address(0xdead),
                stakeAmount: 0,
                evidenceHash: bytes32(i),
                fallbackTermsHash: bytes32(0),
                l2BlockNumber: block.number
            });
            try batcher.queueDisputeInitiation(msg_) {} catch {}
        }
    }
}

// ============ Main Test Contract ============

contract SecurityExploitsTest is Test {
    // Contracts
    ILRM public ilrm;
    NatLangChainTreasury public treasury;
    DIDRegistry public didRegistry;
    L3Bridge public l3Bridge;
    L3StateVerifier public stateVerifier;
    L3DisputeBatcher public batcher;

    // Mocks
    MockToken public token;
    MockAssetRegistry public assetRegistry;
    MockOracle public oracle;

    // Addresses
    address public owner = address(this);
    address public initiator = address(0x1);
    address public counterparty = address(0x2);
    address public attacker = address(0x666);
    address public sequencer = address(0x7);

    // Constants
    uint256 constant STAKE = 10 ether;
    uint256 constant SUBSIDY_MAX = 100 ether;

    IILRM.FallbackLicense fallbackLicense = IILRM.FallbackLicense({
        nonExclusive: true,
        termDuration: 365 days,
        royaltyCapBps: 500,
        termsHash: bytes32(uint256(0xabc))
    });

    function setUp() public {
        // Deploy mocks
        token = new MockToken();
        assetRegistry = new MockAssetRegistry();
        oracle = new MockOracle();

        // Deploy core contracts
        ilrm = new ILRM(IERC20(token), address(oracle), IAssetRegistry(assetRegistry));
        treasury = new NatLangChainTreasury(IERC20(token), SUBSIDY_MAX, SUBSIDY_MAX * 10, 30 days);
        didRegistry = new DIDRegistry();
        l3Bridge = new L3Bridge(address(ilrm));
        stateVerifier = new L3StateVerifier(address(l3Bridge));
        batcher = new L3DisputeBatcher(address(l3Bridge), address(ilrm));

        // Configure contracts
        treasury.setILRM(address(ilrm));

        // Setup L3Bridge sequencer
        IL3Bridge.SequencerConfig memory config = IL3Bridge.SequencerConfig({
            sequencerAddress: sequencer,
            commitmentInterval: 100,
            challengePeriod: 7 days,
            minBatchSize: 1,
            maxBatchSize: 100
        });
        l3Bridge.updateSequencerConfig(config);

        // Fund accounts
        token.mint(initiator, 1000 ether);
        token.mint(counterparty, 1000 ether);
        token.mint(attacker, 1000 ether);
        token.mint(address(treasury), 10000 ether);

        vm.deal(initiator, 100 ether);
        vm.deal(counterparty, 100 ether);
        vm.deal(attacker, 100 ether);
        vm.deal(address(l3Bridge), 10 ether); // For fraud proof rewards

        // Approve tokens
        vm.prank(initiator);
        token.approve(address(ilrm), type(uint256).max);
        vm.prank(counterparty);
        token.approve(address(ilrm), type(uint256).max);
        vm.prank(attacker);
        token.approve(address(ilrm), type(uint256).max);
    }

    // ============ CRITICAL: L3StateVerifier Unrestricted Proof Caching ============

    /**
     * @notice CRITICAL: Anyone can cache arbitrary proofs as verified
     * @dev This allows bypassing actual proof verification
     */
    function testCritical_UnrestrictedProofCaching() public {
        // Attacker crafts a fake proof hash
        bytes32 fakeProofHash = keccak256("totally_valid_proof_trust_me");

        // Before: not cached
        assertFalse(stateVerifier.isProofCached(fakeProofHash));

        // VULNERABILITY: Anyone can cache this as verified!
        vm.prank(attacker);
        stateVerifier.cacheVerifiedProof(fakeProofHash);

        // After: now cached as "verified"
        assertTrue(stateVerifier.isProofCached(fakeProofHash));

        // This is a critical vulnerability - no access control on cacheVerifiedProof
        // An attacker could mark fake proofs as verified
    }

    // ============ HIGH: L3DisputeBatcher Open Queue ============

    /**
     * @notice HIGH: Anyone can queue dispute initiations
     * @dev Should be restricted to ILRM only
     */
    function testHigh_OpenDisputeQueuing() public {
        IL3Bridge.DisputeInitiationMessage memory maliciousDispute = IL3Bridge.DisputeInitiationMessage({
            l2DisputeId: 1,
            initiator: attacker,
            counterparty: address(0xdead),
            stakeAmount: 0, // Fake stake
            evidenceHash: bytes32(0),
            fallbackTermsHash: bytes32(0),
            l2BlockNumber: block.number
        });

        // VULNERABILITY: Attacker can queue fake disputes!
        vm.prank(attacker);
        uint256 position = batcher.queueDisputeInitiation(maliciousDispute);

        assertEq(position, 0);
        assertEq(batcher.getPendingInitiationsCount(), 1);

        // This allows DoS by filling the queue
        // Or spoofing disputes that weren't actually created
    }

    /**
     * @notice HIGH: Batch can be filled with spam, blocking legitimate disputes
     */
    function testHigh_BatchSpamDoS() public {
        // Fill batch to max
        for (uint256 i = 0; i < 50; i++) {
            IL3Bridge.DisputeInitiationMessage memory spam = IL3Bridge.DisputeInitiationMessage({
                l2DisputeId: 1000 + i,
                initiator: attacker,
                counterparty: address(0xdead),
                stakeAmount: 0,
                evidenceHash: bytes32(i),
                fallbackTermsHash: bytes32(0),
                l2BlockNumber: block.number
            });

            vm.prank(attacker);
            batcher.queueDisputeInitiation(spam);
        }

        assertEq(batcher.getPendingInitiationsCount(), 50);

        // Now legitimate user can't queue
        IL3Bridge.DisputeInitiationMessage memory legitimate = IL3Bridge.DisputeInitiationMessage({
            l2DisputeId: 9999,
            initiator: initiator,
            counterparty: counterparty,
            stakeAmount: STAKE,
            evidenceHash: bytes32(uint256(0x123)),
            fallbackTermsHash: bytes32(uint256(0x456)),
            l2BlockNumber: block.number
        });

        vm.prank(initiator);
        vm.expectRevert(L3DisputeBatcher.BatchFull.selector);
        batcher.queueDisputeInitiation(legitimate);
    }

    // ============ HIGH: Front-running MEV Vulnerabilities ============

    /**
     * @notice HIGH: Fraud proofs can be front-run by MEV bots
     * @dev The first valid submitter gets the reward, allowing MEV extraction
     */
    function testHigh_FraudProofFrontrunning() public {
        // Setup: Create a state commitment
        vm.startPrank(sequencer);

        bytes32 stateRoot = keccak256("fake_state");
        bytes32 previousRoot = bytes32(0);
        bytes memory sig = _signStateCommitment(stateRoot, 1, 0, previousRoot);

        IL3Bridge.StateCommitment memory commitment = IL3Bridge.StateCommitment({
            stateRoot: stateRoot,
            blockNumber: 1,
            timestamp: block.timestamp,
            disputeCount: 0,
            previousRoot: previousRoot,
            sequencerSignature: sig
        });

        l3Bridge.submitStateCommitment(commitment);
        vm.stopPrank();

        // Honest user discovers fraud and prepares proof
        IL3Bridge.FraudProof memory proof = IL3Bridge.FraudProof({
            claimedRoot: stateRoot,
            correctRoot: keccak256("correct_state"),
            disputeId: 0,
            invalidStateData: abi.encodePacked(stateRoot), // Simplified
            merkleProof: new bytes32[](0)
        });

        // In a real scenario, attacker would see this in mempool and front-run
        // The current implementation gives reward to first submitter

        // Attacker front-runs (submits first)
        vm.prank(attacker);
        // This would work if fraud proof is valid - attacker steals honest user's discovery
        // vm.expectRevert(); // Only if proof is invalid
    }

    // ============ MEDIUM: Treasury Reentrancy on ETH Withdrawal ============

    /**
     * @notice MEDIUM: emergencyWithdrawETH lacks reentrancy guard
     * @dev Owner-only mitigates risk, but pattern is dangerous
     */
    function testMedium_TreasuryETHWithdrawalNoReentrancyGuard() public {
        // Fund treasury with ETH
        vm.deal(address(treasury), 10 ether);

        // This is owner-only, so direct attack fails
        vm.prank(attacker);
        vm.expectRevert(); // Not owner
        treasury.emergencyWithdrawETH(attacker, 1 ether);

        // But if owner calls malicious contract...
        // The function has no reentrancy guard
        TreasuryReentrancyAttacker attackContract = new TreasuryReentrancyAttacker(address(treasury));

        // Owner withdrawal works
        treasury.emergencyWithdrawETH(address(attackContract), 1 ether);

        // Note: Attack would only work if receive() could re-enter
        // Currently owner checks prevent full exploitation
    }

    // ============ MEDIUM: L3Bridge pendingSettlementsCount Never Updated ============

    /**
     * @notice MEDIUM: pendingSettlementsCount is declared but never modified
     * @dev View function returns incorrect data
     */
    function testMedium_PendingSettlementsCountNeverUpdated() public {
        // Initial count should be 0
        assertEq(l3Bridge.getPendingSettlementsCount(), 0);

        // Even after processing settlements, count stays 0
        // This is because _processSettlement never updates pendingSettlementsCount
        // Bug: The counter is declared but never incremented/decremented
    }

    // ============ MEDIUM: DIDRegistry Unbounded Credential Array ============

    /**
     * @notice MEDIUM: Revoked credentials stay in array, growing unboundedly
     * @dev Can lead to gas exhaustion in sybil score calculation
     */
    function testMedium_UnboundedCredentialArrayGrowth() public {
        // Register DID
        vm.prank(initiator);
        bytes32 did = didRegistry.registerDID(bytes32(uint256(0x123)));

        // Add trusted issuer
        IDIDRegistry.AttestationType[] memory types = new IDIDRegistry.AttestationType[](1);
        types[0] = IDIDRegistry.AttestationType.GovernmentID;
        didRegistry.addTrustedIssuer(address(this), "TestIssuer", types, 100);

        // Issue many credentials
        bytes32[] memory credIds = new bytes32[](50);
        for (uint256 i = 0; i < 50; i++) {
            credIds[i] = didRegistry.issueCredential(
                did,
                IDIDRegistry.AttestationType.GovernmentID,
                bytes32(i),
                0,
                50
            );
        }

        // Revoke all credentials
        for (uint256 i = 0; i < 50; i++) {
            didRegistry.revokeCredential(credIds[i], "revoked");
        }

        // Credentials are revoked but still in array
        bytes32[] memory storedCreds = didRegistry.getCredentials(did);
        assertEq(storedCreds.length, 50); // All still there!

        // Score calculation still iterates over all 50
        // This gets expensive as more credentials are added
    }

    // ============ MEDIUM: State Commitment Chain Fork Risk ============

    /**
     * @notice MEDIUM: Multiple state roots can reference same previousRoot
     * @dev Creates potential for chain forks before finalization
     */
    function testMedium_StateCommitmentForkRisk() public {
        vm.startPrank(sequencer);

        bytes32 genesis = bytes32(0);

        // First commitment
        bytes32 root1 = keccak256("state1");
        bytes memory sig1 = _signStateCommitment(root1, 1, 0, genesis);
        IL3Bridge.StateCommitment memory commit1 = IL3Bridge.StateCommitment({
            stateRoot: root1,
            blockNumber: 1,
            timestamp: block.timestamp,
            disputeCount: 0,
            previousRoot: genesis,
            sequencerSignature: sig1
        });
        l3Bridge.submitStateCommitment(commit1);

        // Second commitment with SAME previousRoot (fork!)
        bytes32 root2 = keccak256("state2");
        bytes memory sig2 = _signStateCommitment(root2, 2, 0, genesis);
        IL3Bridge.StateCommitment memory commit2 = IL3Bridge.StateCommitment({
            stateRoot: root2,
            blockNumber: 2,
            timestamp: block.timestamp,
            disputeCount: 0,
            previousRoot: genesis, // Same parent!
            sequencerSignature: sig2
        });

        // This should ideally fail (fork detection) but it succeeds
        // because previousRoot check only validates against latestFinalizedRoot
        // which is still bytes32(0) since neither is finalized
        l3Bridge.submitStateCommitment(commit2);

        vm.stopPrank();

        // Both roots are now valid pending commitments!
        // This is a fork in the state chain
    }

    // ============ LOW: ILRM startTime Manipulation ============

    /**
     * @notice LOW: Counter-proposals extend resolution deadline
     * @dev Can delay resolution by up to 3 days (by design but worth noting)
     */
    function testLow_StartTimeExtensionViaCounterProposals() public {
        uint256 disputeId = _createFullyStakedDispute();

        (,,,,uint256 startTime,,,,,,,) = ilrm.disputes(disputeId);
        uint256 originalStart = startTime;

        // Submit 3 counter-proposals
        for (uint256 i = 0; i < 3; i++) {
            uint256 fee = 0.01 ether * (1 << i); // Exponential
            vm.deal(initiator, fee);
            vm.prank(initiator);
            ilrm.counterPropose{value: fee}(disputeId, bytes32(i));
        }

        (,,,,uint256 newStartTime,,,,,,,) = ilrm.disputes(disputeId);

        // startTime extended by 3 days
        assertEq(newStartTime, originalStart + 3 days);
    }

    // ============ LOW: DID _canIssueType Unbounded Loop ============

    /**
     * @notice LOW: No limit on allowedTypes array size for issuers
     * @dev Could cause gas issues if owner adds many types
     */
    function testLow_UnboundedIssuerTypesLoop() public {
        // Create an issuer with many allowed types
        IDIDRegistry.AttestationType[] memory types = new IDIDRegistry.AttestationType[](6);
        types[0] = IDIDRegistry.AttestationType.GovernmentID;
        types[1] = IDIDRegistry.AttestationType.Biometric;
        types[2] = IDIDRegistry.AttestationType.SocialMedia;
        types[3] = IDIDRegistry.AttestationType.FinancialInstitution;
        types[4] = IDIDRegistry.AttestationType.ReputationBased;
        types[5] = IDIDRegistry.AttestationType.CrossChain;

        didRegistry.addTrustedIssuer(address(this), "MultiTypeIssuer", types, 100);

        // Each credential issuance iterates through all types
        // With more types, gas cost increases linearly
    }

    // ============ Access Control Tests ============

    /**
     * @notice Verify ILRM oracle restriction works
     */
    function testAccessControl_OnlyOracleCanSubmitProposals() public {
        uint256 disputeId = _createFullyStakedDispute();

        vm.prank(attacker);
        vm.expectRevert("Only oracle");
        ilrm.submitLLMProposal(disputeId, "malicious proposal", "");
    }

    /**
     * @notice Verify L3Bridge sequencer restriction works
     */
    function testAccessControl_OnlySequencerCanSubmitCommitments() public {
        bytes32 root = keccak256("fake");
        IL3Bridge.StateCommitment memory commitment = IL3Bridge.StateCommitment({
            stateRoot: root,
            blockNumber: 1,
            timestamp: block.timestamp,
            disputeCount: 0,
            previousRoot: bytes32(0),
            sequencerSignature: ""
        });

        vm.prank(attacker);
        vm.expectRevert(abi.encodeWithSelector(IL3Bridge.NotSequencer.selector, attacker));
        l3Bridge.submitStateCommitment(commitment);
    }

    /**
     * @notice Verify Treasury ILRM restriction works
     */
    function testAccessControl_OnlyILRMCanUpdateHarassmentScore() public {
        vm.prank(attacker);
        vm.expectRevert(abi.encodeWithSelector(NatLangChainTreasury.NotILRM.selector, attacker));
        treasury.updateHarassmentScore(initiator, 10);
    }

    /**
     * @notice Verify DID controller restrictions work
     */
    function testAccessControl_OnlyControllerCanModifyDID() public {
        vm.prank(initiator);
        bytes32 did = didRegistry.registerDID(bytes32(uint256(0x123)));

        vm.prank(attacker);
        vm.expectRevert(abi.encodeWithSelector(IDIDRegistry.NotDIDController.selector, did, attacker));
        didRegistry.updateDIDDocument(did, bytes32(uint256(0x456)));
    }

    // ============ Economic Attack Tests ============

    /**
     * @notice Test that escalation multiplier is enforced
     */
    function testEconomic_EscalationMultiplierEnforced() public {
        // First dispute
        vm.prank(initiator);
        ilrm.initiateBreachDispute(counterparty, STAKE, bytes32(uint256(0x123)), fallbackLicense);

        // Second dispute within cooldown should require 1.5x stake
        vm.prank(initiator);
        vm.expectRevert(); // Insufficient stake
        ilrm.initiateBreachDispute(counterparty, STAKE, bytes32(uint256(0x456)), fallbackLicense);

        // With 1.5x stake it works
        vm.prank(initiator);
        ilrm.initiateBreachDispute(counterparty, (STAKE * 150) / 100, bytes32(uint256(0x789)), fallbackLicense);
    }

    /**
     * @notice Test treasury subsidy cannot be front-run
     */
    function testEconomic_SubsidyFrontrunningProtection() public {
        // Create dispute where counterparty needs subsidy
        vm.prank(initiator);
        uint256 disputeId = ilrm.initiateBreachDispute(counterparty, STAKE, bytes32(uint256(0x123)), fallbackLicense);

        // Attacker tries to request subsidy for counterparty
        vm.prank(attacker);
        vm.expectRevert(abi.encodeWithSelector(NatLangChainTreasury.NotCounterparty.selector, attacker, counterparty));
        treasury.requestSubsidy(disputeId, STAKE, counterparty);

        // Only counterparty can request their own subsidy
        vm.prank(counterparty);
        // Would work if counterparty is the one calling
        // (May revert for other reasons in test setup but demonstrates the fix)
    }

    /**
     * @notice Test harassment score blocks subsidies
     */
    function testEconomic_HarassmentScoreBlocksSubsidy() public {
        // Mark counterparty as harasser
        address[] memory participants = new address[](1);
        participants[0] = counterparty;
        uint256[] memory scores = new uint256[](1);
        scores[0] = 75; // Above HARASSMENT_THRESHOLD of 50

        treasury.batchSetHarassmentScores(participants, scores);

        // Create dispute
        vm.prank(initiator);
        uint256 disputeId = ilrm.initiateBreachDispute(counterparty, STAKE, bytes32(uint256(0x123)), fallbackLicense);

        // Counterparty's subsidy request fails
        vm.prank(counterparty);
        vm.expectRevert(abi.encodeWithSelector(
            NatLangChainTreasury.ParticipantFlaggedForAbuse.selector,
            counterparty,
            75
        ));
        treasury.requestSubsidy(disputeId, STAKE, counterparty);
    }

    // ============ Pause Tests ============

    /**
     * @notice Verify pause blocks critical operations
     */
    function testPause_BlocksCriticalOperations() public {
        // Pause ILRM
        ilrm.pause();

        vm.prank(initiator);
        vm.expectRevert();
        ilrm.initiateBreachDispute(counterparty, STAKE, bytes32(uint256(0x123)), fallbackLicense);

        // Pause DIDRegistry
        didRegistry.pause();

        vm.prank(initiator);
        vm.expectRevert();
        didRegistry.registerDID(bytes32(uint256(0x123)));
    }

    // ============ Helper Functions ============

    function _createFullyStakedDispute() internal returns (uint256 disputeId) {
        vm.prank(initiator);
        disputeId = ilrm.initiateBreachDispute(counterparty, STAKE, bytes32(uint256(0x123)), fallbackLicense);

        vm.prank(counterparty);
        ilrm.depositStake(disputeId);
    }

    function _signStateCommitment(
        bytes32 root,
        uint256 blockNumber,
        uint256 disputeCount,
        bytes32 previousRoot
    ) internal view returns (bytes memory) {
        // Simplified - in production would use actual ECDSA
        bytes32 messageHash = keccak256(abi.encodePacked(
            root,
            blockNumber,
            disputeCount,
            previousRoot
        ));
        // Return empty sig since we're using sequencer address that matches
        return "";
    }
}

// ============ Additional Attack Scenarios ============

/**
 * @title AdvancedExploitTests
 * @notice Additional exploit scenarios for edge cases
 */
contract AdvancedExploitTests is Test {
    // Test signature replay attacks, timestamp manipulation, etc.

    /**
     * @notice Test that challenges prevent finalization
     */
    function testChallengeBlocksFinalization() public {
        // Would test that an active challenge on a state root
        // prevents that root from being finalized
    }

    /**
     * @notice Test that expired challenges can be recovered
     */
    function testExpiredChallengeRecovery() public {
        // Would test edge cases around challenge expiry
    }

    /**
     * @notice Test batch size limits are enforced
     */
    function testBatchSizeLimitsEnforced() public {
        // Would test that MAX_BATCH_SIZE cannot be exceeded
    }
}
